rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------
    // Helper Functions
    // -------------------------------
    function isLoggedIn() {
      return request.auth != null;
    }

    // This looks up the role in your Database (checks staff collection first, then users collection)
    function getRole() {
      if (!isLoggedIn()) {
        return null;
      }
      // Try to get the staff document first (primary collection)
      let staffDoc = get(/databases/$(database)/documents/staff/$(request.auth.uid));
      if (staffDoc.exists && 'role' in staffDoc.data) {
        return staffDoc.data.role;
      }
      // Fallback to users collection for backward compatibility
      let userDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return userDoc.exists && 'role' in userDoc.data ? userDoc.data.role : null;
    }

    // Role Checks (Case insensitive just to be safe if you want)
    function isAdmin() {
      return getRole() == "admin" || getRole() == "Admin";
    }

    function isFrontdesk() {
      return getRole() == "frontdesk" || getRole() == "FrontDesk";
    }

    function isClinic() {
      return getRole() == "clinic" || getRole() == "ClinicalTeam";
    }

    // Check if staff document belongs to the authenticated user
    function isOwnStaffDoc() {
      if (!isLoggedIn()) {
        return false;
      }
      
      // For updates: check existing document (resource exists for updates, not for creates)
      let matchesExisting = false;
      if (resource != null) {
        matchesExisting = 
          ('authUid' in resource.data && request.auth.uid == resource.data.authUid) ||
          (request.auth.token.email != null && 
           'userEmail' in resource.data &&
           request.auth.token.email == resource.data.userEmail);
      }
      
      // For creates/updates: check new data being written
      let matchesNew = 
        ('authUid' in request.resource.data && request.auth.uid == request.resource.data.authUid) ||
        (request.auth.token.email != null && 
         'userEmail' in request.resource.data &&
         request.auth.token.email == request.resource.data.userEmail);
      
      return matchesExisting || matchesNew;
    }

    // -------------------------------
    // USERS COLLECTION
    // -------------------------------
    match /users/{uid} {
      // Users can view their own profile; admins can view all
      allow read: if isLoggedIn() && 
                  (request.auth.uid == uid || isAdmin());
      
      // Admin can edit any user; user can edit their own doc
      allow write: if isAdmin() || request.auth.uid == uid;
    }

    // -------------------------------
    // PATIENTS COLLECTION
    // -------------------------------
    match /patients/{id} {
      allow read: if isLoggedIn();
      allow create, update: if isFrontdesk() || isAdmin();
      allow delete: if isAdmin();
    }

    // -------------------------------
    // APPOINTMENTS COLLECTION
    // -------------------------------
    match /appointments/{id} {
      allow read: if isLoggedIn();
      allow create: if isFrontdesk() || isAdmin() || isClinic();
      allow update: if isFrontdesk() || isAdmin() || isClinic();
      allow delete: if isAdmin() || isFrontdesk();
    }

    // -------------------------------
    // BILLING COLLECTION
    // -------------------------------
    match /billing/{id} {
      allow read: if isLoggedIn();
      allow create, update: if isFrontdesk() || isAdmin();
      allow delete: if isAdmin();
    }

    // -------------------------------
    // STAFF COLLECTION
    // -------------------------------
    match /staff/{id} {
      allow read: if isLoggedIn();
      
      // Admin can write anyone. 
      // Staff/Doctors can only update their OWN profile (based on authUid or userEmail)
      allow write: if isLoggedIn() && (
        isAdmin() || 
        isOwnStaffDoc()
      );
    }

    // -------------------------------
    // NOTIFICATIONS COLLECTION
    // -------------------------------
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if isLoggedIn() && 
                  resource.data.userId == request.auth.uid;
      
      // Allow any logged-in user to create notifications
      // (Business logic ensures only admins can create notifications for others)
      // This avoids permission issues with role lookup in rules
      allow create: if isLoggedIn() && 
                    request.resource.data.userId != null &&
                    request.resource.data.title != null &&
                    request.resource.data.message != null;
      
      // Users can update their own notifications (e.g., mark as read)
      allow update: if isLoggedIn() && 
                    resource.data.userId == request.auth.uid;
      
      // Only admins can delete notifications
      allow delete: if isAdmin();
    }

    // -------------------------------
    // APP NOTIFICATIONS COLLECTION
    // -------------------------------
    match /appNotifications/{notificationId} {
      // All logged-in users can read app notifications
      allow read: if isLoggedIn();
      
      // Allow any logged-in user to create app notifications
      allow create: if isLoggedIn() && 
                    request.resource.data.type != null &&
                    request.resource.data.title != null &&
                    request.resource.data.message != null;
      
      // Users can update app notifications (e.g., mark as read)
      allow update: if isLoggedIn();
      
      // Only admins can delete app notifications
      allow delete: if isAdmin();
    }

    // -------------------------------
    // CONVERSATIONS COLLECTION
    // -------------------------------
    match /conversations/{conversationId} {
      // Users can read conversations they're part of
      allow read: if isLoggedIn() && 
                  request.auth.uid in resource.data.participants;
      
      // Users can create conversations if they're a participant
      allow create: if isLoggedIn() && 
                    request.auth.uid in request.resource.data.participants;
      
      // Users can update conversations they're part of
      allow update: if isLoggedIn() && 
                    request.auth.uid in resource.data.participants;
      
      // Users can delete conversations they're part of
      allow delete: if isLoggedIn() && 
                    request.auth.uid in resource.data.participants;
    }

    // -------------------------------
    // MESSAGES COLLECTION
    // -------------------------------
    match /messages/{messageId} {
      // Helper function to check if user is part of the conversation (for reads/updates)
      function isConversationParticipantForRead() {
        if (!isLoggedIn()) {
          return false;
        }
        // Get the conversation ID from the existing message
        let convId = resource.data.conversationId;
        if (convId == null) {
          return false;
        }
        // Get the conversation document
        let convDoc = get(/databases/$(database)/documents/conversations/$(convId));
        if (!convDoc.exists) {
          return false;
        }
        // Check if user is in participants array
        return request.auth.uid in convDoc.data.participants;
      }
      
      // Helper function to check if user is part of the conversation (for creates)
      function isConversationParticipantForCreate() {
        if (!isLoggedIn()) {
          return false;
        }
        // Get the conversation ID from the new message
        let convId = request.resource.data.conversationId;
        if (convId == null) {
          return false;
        }
        // Get the conversation document
        let convDoc = get(/databases/$(database)/documents/conversations/$(convId));
        if (!convDoc.exists) {
          return false;
        }
        // Check if user is in participants array
        return request.auth.uid in convDoc.data.participants;
      }
      
      // Users can read messages in conversations they're part of
      allow read: if isLoggedIn() && isConversationParticipantForRead();
      
      // Users can create messages if they're the sender
      // Allow creation even if conversation doesn't exist yet (it will be created)
      allow create: if isLoggedIn() && 
                    request.resource.data.senderId == request.auth.uid &&
                    request.resource.data.conversationId != null &&
                    request.resource.data.text != null;
      
      // Users can update messages (e.g., reactions, read status) if they're part of conversation
      allow update: if isLoggedIn() && isConversationParticipantForRead();
      
      // Only admins can delete messages
      allow delete: if isAdmin();
    }

    // -------------------------------
    // DENY EVERYTHING ELSE
    // -------------------------------
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
